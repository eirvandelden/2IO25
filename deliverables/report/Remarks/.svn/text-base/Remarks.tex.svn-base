\section{Concluding remarks}
\label{sec:Remarks}
We have learned how to implement and test an algorithm. From these test we have enhanced our original algorithm. We have also learned that the solution to any problem is in essence a ``hit or miss''. An engineer must have the right idea at the right time with the right skills to solve a problem. Our first approaches, using a $k$D-tree and making a backtracking algorithm were the wrong ideas. The first because it was too complex to implement, the second because the practical running time was worthless (caused by both the large stack problems of FreePascal and the properties of any backtracking algorithm ).\\
In the end, we have decided to use more simple algorithms to achieve the expected results. We began with implementing a Nearest Neighbor algorithm, which has a running time of $O(n^{2})$, so it was pretty fast. When we tested this algorithm it turned out this was not enough to solve the problem of curve reconstruction. There was a lot of zigzagging in the resulting figures and lines from one end of the figure to the other. The last problem was caused by the fact that when \textit{NearestNeighbor} is about to connect the last point it checks whether all points in the input array are used, if this is not the case it connects them, which can result in such lines.\\


Therefore, the next idea was to improve this algorithm by looking at the direction of the curve constructed so far. We developed functions to find points within a certain range from the current point, and a function to determine which of the just found points differs the least from the current direction. To get rid of the lines running from one end of the figure to the other caused by skipping points, we insert these skipped points into the solution array at the right spot in the end. This way no lines from one end of the figure to the other are possible. We called this algorithm \textit{DirectedNearestNeighbor}, because its main functionality is looking at direction. This algorithm also has an running time of $O(n^{2})$, so it was still fast enough to solve the problem within the amount of time that was given, namely 5 minutes. From the test results of this algorithm we concluded that in most cases the zigzagging was gone, but the most resulting figures were still not what we wished for, but when we ran \textit{DirectedNearestNeighbor} on self-intersecting curves it gave good results. So we decided to use this algorithm for self-intersecting curves.\\
For the other three types of curves we have improved \textit{NearestNeighbor}. This new algorithm, called \textit{ImprovedNearestNeighbor} still inserts skipped points, but also has a new function to make open curves. This is done by deleting the longest edge after constructing a closed curve. Also this algorithm still has a running time of $O(n^2)$. The results were satisfying for the open and closed curve test-cases, so we decided to use this algorithm for those two types.\\
That left us with one type of curve: the up-to-5 curve. For this case we designed a new algorithm still based on \textit{NearestNeighbor} without checking whether all points occur in the solution array. When \textit{NearestNeighbor} has constructed a curve, this curve is stored in a solution array and the remaining points in the set are used to construct another curve, this continues until all points are used. When at the end more than $5$ curves were created the smaller curves are inserted into the closest big curve, until less than $5$ curves occur in the solution. This way we can guarantee no more than $5$ curves are returned. Though the worst-case running time of this algorithm, called \textit{UpToFiveSort}, is $O(n^{3})$ it turns out on the average case its linear! The results were very good, so we did not need to improve this algorithm anymore.\\
Of course there is always room for improvements on all the algorithms we made. One of them is to check for intersections; in a self-intersecting curve a check is needed wether it contains at least one intersection, on the other hand in an open, closed or up-to-five curve no intersections are allowed. If this check is added you can guarantee that the solution given by the algorithms always satisfies the conditions of the different types of curves.\\
